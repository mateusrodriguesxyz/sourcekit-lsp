//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2024 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import Foundation
import RegexBuilder
import class TSCBasic.Process

package struct ActiveRequestsCommand: AsyncParsableCommand {
  package static let configuration: CommandConfiguration = CommandConfiguration(
    commandName: "active-requests",
    abstract: "Shows the requests that are currently being handled by sourcekit-lsp.",
    discussion: "This command only works on macOS."
  )

  @Option(
    name: .customLong("log-file"),
    help: """
      Instead of reading the currently executing requests from recent system messages, read them from a log file, \
      generated by `log show`.
      """
  )
  var logFile: String?

  package init() {}

  /// Read the last 3 minutes of OSLog output, including signpost messages.
  package func readOSLog() async throws -> String {
    var data = Data()
    let process = Process(
      arguments: [
        "/usr/bin/log",
        "show",
        "--last", "3m",
        "--predicate", #"subsystem = "org.swift.sourcekit-lsp.message-handling" AND process = "sourcekit-lsp""#,
        "--signpost",
      ],
      outputRedirection: .stream(
        stdout: { data += $0 },
        stderr: { _ in }
      )
    )
    try process.launch()
    try await process.waitUntilExit()
    guard let result = String(data: data, encoding: .utf8) else {
      throw GenericError("Failed to decode string from OS Log")
    }
    return result
  }

  package func run() async throws {
    let log: String
    if let logFile {
      log = try String(contentsOf: URL(fileURLWithPath: logFile), encoding: .utf8)
    } else {
      log = try await readOSLog()
    }
    let logParseRegex = Regex {
      #/.*/#
      "[spid 0x"
      Capture {  // Signpost ID
        OneOrMore(.hexDigit)
      }
      ", process, "
      ZeroOrMore(.whitespace)
      Capture {  // Event ("begin", "event", "end")
        #/[a-z]+/#
      }
      "]"
      ZeroOrMore(.any)
    }
    var messagesBySignpostID: [Substring: [Substring]] = [:]
    var endedSignposts: Set<Substring> = []
    for line in log.split(separator: "\n") {
      guard let match = try logParseRegex.wholeMatch(in: line) else {
        continue
      }
      let (signpostID, event) = (match.1, match.2)
      messagesBySignpostID[signpostID, default: []].append(line)
      if event == "end" {
        endedSignposts.insert(signpostID)
      }
    }
    let activeSignpostMessages =
      messagesBySignpostID
      .filter({ !endedSignposts.contains($0.key) })
      .sorted(by: { $0.key < $1.key })
      .flatMap(\.value)
    print(activeSignpostMessages.joined(separator: "\n"))
  }
}
